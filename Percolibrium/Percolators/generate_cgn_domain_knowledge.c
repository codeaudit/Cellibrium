/*****************************************************************************/
/*                                                                           */
/* File: generate_cgn_domain_knowledge.c                                     */
/*                                                                           */
/* Created: Mon Nov 21 14:10:46 2016                                         */
/*                                                                           */
/*****************************************************************************/

 // Conceptual sketch for convergently updating graph knowledge representation
 // This marries/matches with Narrators/stories-fs.c

 // gcc -o gen_knowledge -g -std=c99 generate_cgn_domain_knowledge.c

 // Usage example: ./gen_knowledge > ExampleTupleData/domain_knowledge_graph

#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <utime.h>

typedef int Policy;  // Hack to use CGNgine defs

#define true 1
#define false 0
#define CGN_BUFSIZE 256
#define MAX_ASSOC_ARRAY 128

// Import standard link definitions

#define GRAPH 1
#include "../../RobIoTs/CGNgine/libpromises/graph.h"
#include "../../RobIoTs/CGNgine/libpromises/graph_defs.c"

/******************************************************************************/

void main()
{
 Gr(stdout,"operating system",a_generalizes,"linux","all contexts");

// These tuples might be generated by a code audit / scanner

 RoleCluster(consc,"CGNgine error messages","error messages", "CGNgine", "all contexts");
 
 Gr(stdout,"CGNgine error messages",a_contains,"Cannot mix CIDR notation with xxx-yyy range notation *",ContextCluster(stdout,"system errors and faults"));
 Gr(stdout,ContextCluster(stdout,"CGNgine error messages"),a_contains,"Not a valid address range - or not a fully qualified name *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Cannot handle ipv6 masks which are not 8 bit multiples (fix me)","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Mixture of IPv6 and IPv4 addresses","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Cannot mix CIDR notation with xx-yy range notation","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"FIPS mode is enabled, and md5 is not an approved algorithm","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"process_select body missing its a process_result return value","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"bundle_return_value promise for * in bundle * with too many constraints (ignored)","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Unsupported database type * in databases promise","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Neighbour IP address should be a host not be a network address * in BGP interface promise","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Unsupported user policy * in users promise","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Error writing marker file *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Error removing marker file *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Failed to decrypt string","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Failed to repair database *, recreating...","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Host class counting is only available in CFEngine Enterprise","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Chop was called on a string that seemed to have no terminator","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Bundle aborted on defined class *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Setting abort for * when setting *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Unable to parse class expression *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Syntax error in expression *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"While persisting class *, error reading existing value","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Chop was called on a string that seemed to have no terminator","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Bundle aborted on defined class *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Setting abort for * when setting class *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"The value of variable * contains a reference to itself, *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"An item in list variable * contains a reference to itself","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Variable *' cannot be added because ","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"You cannot use reserved hard class * as post-condition class","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"You cannot cancel a reserved hard class * in post-condition classes","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Unable to open private log *","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"Could not get host entry age","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"getusers is not implemented","system errors and faults");
Gr(stdout,"CGNgine error messages",a_contains,"FIPS mode is enabled and md5 is not an approved algorithm","system errors and faults");

// Derivatives

Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_related_to,"CIDR","all contexts");
Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_depends,"CIDR","all contexts");
Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_depends,"xxx-yyy range notation","all contexts");
Gr(stdout,"xxx-yyy range notation",a_alias,"range notation",ContextCluster(stdout,"system policy syntax CGNgine"));

Gr(stdout,"CIDR",a_related_to,"Classless Internet Domain Routing","*");
Gr(stdout,"CIDR",a_related_to,"Routing","*");

Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_caused_by,"network policy","system errors and faults");
Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_caused_by,"FuzzySetMatch","system errors and faults");

// Trying to curate the story now....:( This is about information/documentation design
// We can try to make documentation causal instead of encyclopaedic

Gr(stdout,"Cannot mix CIDR notation with xxx-yyy range notation *", a_caused_by,"incorrect use of network pattern matching","system errors and faults");

Gr(stdout,"incorrect use of network pattern matching",a_related_to,ContextCluster(stdout,"network pattern matching"), "system errors and faults");

Gr(stdout,ContextCluster(stdout,"pattern matching"), a_contains, "network pattern matching","*");
Gr(stdout,"pattern matching", a_contains, "wildcards","*");
Gr(stdout,"pattern matching", a_contains, "regular expressions","*");


Gr(stdout, "iprange" ,a_uses,"FuzzySetMatch","software");
Gr(stdout, "iprange" ,a_depends,"network pattern matching","software");


Gr(stdout, "iprange" ,a_hasrole,"CGNgine class function","software");
Gr(stdout, "iprange" ,a_hasrole,"host classifier","software");
Gr(stdout, "iprange" ,a_hasattr,"host","software");
Gr(stdout, "iprange" ,a_hasattr,"host classifier","software");

Gr(stdout, "class or context label" ,a_alias,"host classifier","system monitoring");

Gr(stdout, ContextCluster(stdout,"CGNgine class function"),a_contains,"iprange","software");
Gr(stdout, "system policy", a_contains, "CGNgine class function","software");
Gr(stdout, "CGNgine class function", a_contains,"CGNgine function","all contexts");
Gr(stdout, "CGNgine policy language", a_contains, "CGNgine functions","all contexts");
Gr(stdout,"network policy",a_contains,"interfaces configuration","computer software CGNgine");

}

/**********************************************************************/

void Gr(FILE *consc,char *from, enum associations assoc, char *to, char *context)
{
 fprintf(consc,"(%s,%d,%s,%s,%s,%s)\n",from,A[assoc].type,A[assoc].fwd,to,A[assoc].bwd,context);
}

/**********************************************************************/

void GrNOT(FILE *consc,char *from, enum associations assoc, char *to, char *context)
{
 fprintf(consc,"(%s,%d,NOT %s,%s,NOT %s,%s)\n",from,A[assoc].type,A[assoc].fwd,to,A[assoc].bwd,context);
}

/**********************************************************************/

char *RoleCluster(FILE *consc,char *compound_name, char *role, char *attributes, char *ex_context)

/* Document a compound Split a comma separated list, with head
   we can use it for context or for conceptual
   RoleCluster(fp, "compound name", "hasrole unique identifier", "hasttr part1,hasttr part2", "naming unique identity")
*/
    
{ char *sp, word[255];

 Gr(consc,compound_name,a_hasrole,role,ex_context);
 
 if ((sp = attributes))
    {
    while (*sp != '\0')
       {
       if (*sp == ',')
          {
          sp++;
          continue;
          }
       
       word[0] = '\0';
       sscanf(sp,"%250[^,]",word);
       sp += strlen(word);

       Gr(consc,compound_name,a_hasattr,word,"all contexts");
       }
    }

return compound_name;
}

/**********************************************************************/

char *ContextCluster(FILE *consc,char *compound_name)

/* Document a compound Split a space separated list, with head
   we can use it for context or for conceptual - treat them as epitopes
   for fuzzy matching by set overlap. Only type 1 associations. */
    
{ char *sp, word[255];

 if ((sp = compound_name))
    {
    while (*sp != '\0')
       {
       if (*sp == ' ')
          {
          sp++;
          continue;
          }
       
       word[0] = '\0';
       sscanf(sp,"%250s",word);
       sp += strlen(word);

       Gr(consc,compound_name,a_contains,word,"all contexts");
       }
    }

return compound_name;
}

