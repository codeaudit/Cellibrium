/*****************************************************************************/
/*                                                                           */
/* File: generate_cgn_domain_knowledge.c                                     */
/*                                                                           */
/* Created: Mon Nov 21 14:10:46 2016                                         */
/*                                                                           */
/*****************************************************************************/

 // Conceptual sketch for convergently updating graph knowledge representation
 // This marries/matches with Narrators/stories-fs.c

 // gcc -o gen_knowledge -g -std=c99 generate_cgn_domain_knowledge.c

 // Usage example: ./gen_knowledge > ExampleTupleData/domain_knowledge_graph

#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <utime.h>

typedef int Policy;  // Hack to use CGNgine defs

#define true 1
#define false 0
#define CGN_BUFSIZE 256
#define MAX_ASSOC_ARRAY 128

// Import standard link definitions

#define GRAPH 1
#include "../../RobIoTs/CGNgine/libpromises/graph.h"
#include "../../RobIoTs/CGNgine/libpromises/graph_defs.c"

/******************************************************************************/

void main()
{

 ContextCluster(stdout, "doctor service");
 ContextCluster(stdout, "patient appointment");

 // Compound (qualified) concepts

 RoleCluster(consc,"general practictioner doctor","doctor", "general practitioner", "patient health service");
 RoleCluster(consc,"surgeon doctor","doctor", "surgeon", "patient health service");
 RoleCluster(consc,"patient appointment","appointment", "doctor patient", "patient health service");
 RoleCluster(consc,"authenticated doctor","doctor", "authenticated", "patient health service");
 RoleCluster(consc,"authenticated patient","patient", "authenticated", "patient health service");

 
 Gr("public health service",a_depends,"patient appointment","need to see a doctor");
 Gr("public health service",a_depends,"general practictioner doctor","need to see a doctor");



(public health service,2,depends on,patient uses appointment,is required for,need to see a doctor)
(patient appointment,2,depends on,patient doctor register binding,is required for,need to see a doctor)

(patient doctor register binding,2,depends on,doctor patient binding service,is promised by,patient doctor registration)

(doctor,3,promises,public health service,is promised by,need to see a doctor)
(patient,3,promises,patient role,is promised by,need to see a doctor)

(public health service,2,depends on,doctor availability,is required for,need to see a doctor)

(accepted doctor patient binding,2,depends on,doctor,is required for,patient doctor registration)
(accepted doctor patient binding,2,depends on,patient,is required for,patient doctor registration)
(accepted doctor patient binding,2,depends on,doctor authorized,is required for,patient doctor registration)

(accepted doctor patient binding,2,depends on,doctor authenticated,is required for,patient doctor registration)
(accepted doctor patient binding,2,depends on,patient authenticated,is required for,patient doctor registration)

(doctor patient binding service,2,depends on,doctor authenticated,is required for,patient doctor registration)
(doctor patient binding service,2,depends on,patient authenticated,is required for,patient doctor registration)

(doctor authenticated,2,depends on,identity credentials,are required for,identity authentication verification)
(patient authenticated,2,depends on,identity credentials,are required for,identity authentication verification)

% Wizard info gathered as public info, REST query etc

(identity credentials,2,uses step 1,https://url1/form/element1,is a step used to establish,identity authentication verification)
(identity credentials,2,uses step 1,https://url2/form/element2,is a step used to establish,identity authentication verification)

%
% dynamically changing observations (cognitive inputs)
%

% User sensors - what am I doing now?


% query responses become promises

(doctor,3,promises,accepted doctor patient binding,is promised by,patient doctor registration)
(patient,3,promises,accepted doctor patient binding,is promised by,patient doctor registration)

 Gr("entity authentication",a_promises,"authenticated doctor","need to see a doctor");
 
(entity authentication,3,promises,doctor authenticated,is required for,doctor registration)
(entity authentication,3,promises,patient authenticated,is required for,doctor registration)
(medical association,3,promises,doctor authorized,is required for,doctor registration)

(doctor,3,promises,doctor availability,is promised by,patient doctor registration)
(patient uses appointment,3,had outcome,promise kept,was the outcome of,public health service)

% verify credentials

(doctor,3,promises,identity credentials,is promised by,patient doctor registration)
(patient,3,promises,identity credentials,is promised by,patient doctor registration)

% TO DO: add negation of these dependencies, with propagation

% these compounds are state elaborations


}

/**********************************************************************/

void Gr(FILE *consc,char *from, enum associations assoc, char *to, char *context)
{
 fprintf(consc,"(%s,%d,%s,%s,%s,%s)\n",from,A[assoc].type,A[assoc].fwd,to,A[assoc].bwd,context);
}

/**********************************************************************/

void GrNOT(FILE *consc,char *from, enum associations assoc, char *to, char *context)
{
 fprintf(consc,"(%s,%d,NOT %s,%s,NOT %s,%s)\n",from,A[assoc].type,A[assoc].fwd,to,A[assoc].bwd,context);
}

/**********************************************************************/

char *RoleCluster(FILE *consc,char *compound_name, char *role, char *attributes, char *ex_context)

/* Document a compound Split a comma separated list, with head
   we can use it for context or for conceptual
   RoleCluster(fp, "compound name", "hasrole unique identifier", "hasttr part1,hasttr part2", "naming unique identity")
*/
    
{ char *sp, word[255];

 Gr(consc,compound_name,a_hasrole,role,ex_context);
 
 if ((sp = attributes))
    {
    while (*sp != '\0')
       {
       if (*sp == ',')
          {
          sp++;
          continue;
          }
       
       word[0] = '\0';
       sscanf(sp,"%250[^,]",word);
       sp += strlen(word);

       Gr(consc,compound_name,a_hasattr,word,"all contexts");
       }
    }

return compound_name;
}

/**********************************************************************/

char *ContextCluster(FILE *consc,char *compound_name)

/* Document a compound Split a space separated list, with head
   we can use it for context or for conceptual - treat them as epitopes
   for fuzzy matching by set overlap. Only type 1 associations. */
    
{ char *sp, word[255];

 if ((sp = compound_name))
    {
    while (*sp != '\0')
       {
       if (*sp == ' ')
          {
          sp++;
          continue;
          }
       
       word[0] = '\0';
       sscanf(sp,"%250s",word);
       sp += strlen(word);

       Gr(consc,compound_name,a_contains,word,"all contexts");
       }
    }

return compound_name;
}

